package malware_detection

import (
	"encoding/base64"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	glb "github.ibmgcloud.net/dth/inbound_parser/global_structs"
	lg "github.ibmgcloud.net/dth/inbound_parser/logging"
)

func WaitForClamAV(cfg *glb.Config) {
	if !cfg.CheckMalware {
		lg.Logf("don't scan because check_malware is false")
		return
	}

	lg.Logf("waiting for ClamAV to start")
	for true {
		cmd := exec.Command("clamdscan", "--ping", "1")
		_, err := cmd.Output()
		if err == nil {
			break
		}
		time.Sleep(10 * time.Second)
	}
}

func getPath(fileName string, cfg *glb.Config, index int) string {
	sanitizedFileName := base64.StdEncoding.EncodeToString([]byte(fileName))
	sanitizedFileName = strings.ReplaceAll(sanitizedFileName, "/", "_")
	return filepath.Join(cfg.ClamAVScandir, fmt.Sprintf("%d_%s", index, sanitizedFileName))
}

func ContainsMalware(files []glb.File, cfg *glb.Config) (bool, error) {
	if !cfg.CheckMalware {
		return false, nil
	}
	if len(files) == 0 {
		return false, nil
	}

	// delete files in case last execution failed
	err := os.RemoveAll(cfg.ClamAVScandir)
	if err != nil {
		return true, err
	}

	// create scandir
	err = os.Mkdir(cfg.ClamAVScandir, os.ModePerm)
	if err != nil {
		return true, err
	}

	// create files
	for i, file := range files {
		path := getPath(file.Name, cfg, i)
		lg.Logf("writing %s\n", path)

		err = os.WriteFile(path, file.Bytes, 0644)
		if err != nil {
			return true, err
		}
	}

	// check for malware
	var malwareFound bool
	{
		WaitForClamAV(cfg)
		lg.Logf("scanning %s\n", cfg.ClamAVScandir)
		cmd := exec.Command("clamdscan", "-v", cfg.ClamAVScandir)
		msg, err := cmd.Output()
		lg.Logf(string(msg[:]))
		malwareFound = err != nil
	}

	// delete files
	lg.Logf("deleting files")
	err = os.RemoveAll(cfg.ClamAVScandir)
	if err != nil {
		return true, err
	}
	return malwareFound, nil
}
